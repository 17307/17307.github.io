{"meta":{"title":"LillleHoury","subtitle":null,"description":null,"author":"LillleHoury","url":"http://github/17307"},"pages":[{"title":"","date":"2018-06-08T12:38:43.590Z","updated":"2018-06-06T15:21:22.000Z","comments":false,"path":"categories/index.html","permalink":"http://github/17307/categories/index.html","excerpt":"","text":""},{"title":"软件收藏","date":"2018-06-06T16:46:39.000Z","updated":"2018-06-07T02:25:16.000Z","comments":true,"path":"custom/index.html","permalink":"http://github/17307/custom/index.html","excerpt":"","text":"@card{ desktop 配置 软件 来源 作用 truelaunchbar truelaunchbar吧 负责任务栏方面 rolan rolan官网 工具启动箱 everything voidtools 快速查找工具 wox wox官网 辅助rolan 有机会出个truelaunchbar的教程吧…… }"},{"title":"myindex","date":"2018-06-07T01:49:39.000Z","updated":"2018-06-07T01:51:14.000Z","comments":true,"path":"myindex/index.html","permalink":"http://github/17307/myindex/index.html","excerpt":"","text":"123"}],"posts":[{"title":"mongodb","slug":"mongodb","date":"2018-06-17T10:57:07.000Z","updated":"2018-06-17T10:57:29.700Z","comments":true,"path":"2018/06/17/mongodb/","link":"","permalink":"http://github/17307/2018/06/17/mongodb/","excerpt":"mongodb","text":"mongodb Docker &amp;&amp; mongodb 构建环境 docker pull mongo:3.2 docker run -p 27017:27017 -v $PWD/db:/data/db -d mongo:3.2 -p 27017:27017 : 将容器的27017 端口映射到主机的27017 端口-v $PWD/db:/data/db : 将主机中当前目录下的db挂载到容器的/data/db，作为mongo数据存储目录 docker run -it mongo:3.2 mongo --host 172.17.0.1 docker run -it mongo:3.2 运行这个镜像 然后执行命令 mongo --host 172.17.0.1 mongodb mongodb与sql型数据库类比 | SQL术语/概念 | MongoDB术语/概念 | 解释/说明 | | ———— | —————- | ———————————————– | | database | database | 数据库 | | table | collection | 数据库表/集合 | | row | document | 数据记录行/文档 | | column | field | 数据字段/域 | | index | index | 索引 | | table | joins | 表连接,MongoDB不支持 | | primary | key | primary key 主键,MongoDB自动将_id字段设置为主键 | 数据库 一个mongodb中可以建立多个数据库。 MongoDB的默认数据库为”db”，该数据库存储在data目录中。 show dbs 执行 db 命令可以显示当前数据库对象或集合 运行 use 命令，可以连接到一个指定的数据库 use local 文档 文档是一组键值(key-value)对(即BSON) 文档中的键/值对是有序的。 文档中的值不仅可以是在双引号里面的字符串，还可以是其他几种数据类型（甚至可以是整个嵌入的文档)。 MongoDB区分类型和大小写。 MongoDB的文档不能有重复的键。 文档的键是字符串。除了少数例外情况，键可以使用任意UTF-8字符。 集合 集合就是 MongoDB 文档组,类似与sql数据库中的表格 可以将以下不同数据结构的文档插入到集合中: {“site”:”www.baidu.com&quot;}{“site”:”www.google.com&quot;,&quot;name&quot;:&quot;Google&quot;}{“site”:”www.runoob.com&quot;,&quot;name&quot;:&quot;菜鸟教程&quot;,&quot;num&quot;:5} 元数据 数据库一些信息 MongoDB 数据类型 数据库连接 http://www.runoob.com/mongodb/mongodb-connections.html 数据库操作 创建数据库 use DATABASE_NAME 切换到数据库 use my_dababase ; 然后删除数据库 db.dropDatabase() show collections显示集合 创建集合 1.通过db.createCollection(name, options) 2.在 MongoDB 中，你不需要创建集合。当你插入一些文档时，MongoDB 会自动创建集合。 删除集合 use runoob switched to db runoobshow tables sitedb.site.drop() trueshow tables 创建文档 db.COLLECTION_NAME.insert(document) document = ({1:1})db.col.insert(document) 更新文档 方法一 123456789db.collection.update( &lt;query&gt;, # update的查询条件，类似sql update查询内where后面的。 &lt;update&gt;, # update的对象和一些更新的操作符（如$,$inc...）等，也可以理解为sql update查询内set后面的 &#123; upsert: &lt;boolean&gt;, # 可选，这个参数的意思是，如果不存在update的记录，是否插入objNew,true为插入，默认是false，不插入。 multi: &lt;boolean&gt;, # 可选，mongodb 默认是false,只更新找到的第一条记录，如果这个参数为true,就把按条件查出来多条记录全部更新。 writeConcern: &lt;document&gt; # 可选，抛出异常的级别。 &#125; ) db.col.update({&#39;title&#39;:&#39;MongoDB 教程&#39;},{$set:{&#39;title&#39;:&#39;MongoDB&#39;}}) 方法二 1234567/*save() 方法通过传入的文档来替换已有文档*/db.collection.save(&lt;document&gt;,&#123; writeConcern: &lt;document&gt;&#125;) db.collection.updateOne() 向指定集合更新单个文档 db.collection.updateMany() 向指定集合更新多个文档 删除文档 12deleteOne() deleteMany() 如删除集合下全部文档：db.inventory.deleteMany({})删除 status 等于 A 的全部文档：db.inventory.deleteMany({ status : &quot;A&quot; })删除 status 等于 D 的一个文档：db.inventory.deleteOne( { status: &quot;D&quot; } ) 查询 db.collection.find(query, projection) query ：可选，使用查询操作符指定查询条件projection ：可选，使用投影操作符指定返回的键。查询时返回文档中所有键值， 只需省略该参数即可（默认省略）。 AND db.col.find({&quot;by&quot;:&quot;菜鸟教程&quot;, &quot;title&quot;:&quot;MongoDB 教程&quot;}).pretty() OR db.col.find({$or:[{&quot;by&quot;:&quot;菜鸟教程&quot;},{&quot;title&quot;: &quot;MongoDB 教程&quot;}]}).pretty() AND 和 OR db.col.find({&quot;likes&quot;: {$gt:50}, $or: [{&quot;by&quot;: &quot;菜鸟教程&quot;},{&quot;title&quot;: &quot;MongoDB 教程&quot;}]}).pretty() projection 参数的使用方法 db.collection.find(query, {title: 1, by: 1}) // inclusion模式 指定返回的键，不返回其他键 db.collection.find(query, {title: 0, by: 0}) // exclusion模式 指定不返回的键,返回其他键 两种模式不可混用（因为这样的话无法推断其他键是否应返回） 条件查询 db.col.find({likes : {$lt : 150}}) $gt ——– greater than &gt;$gte ——— gt equal &gt;=$lt ——– less than &lt;$lte ——— lt equal &lt;=$ne ———– not equal !=$eq ——– equal = db.col.find({&quot;title&quot; : {$type : 2}}) db.tabl1.deleteOne({&quot;likes&quot;:{$exists: false}}) db.col.find({},{&quot;title&quot;:1,_id:0}).limit(1).skip(1) db.COLLECTION_NAME.find().sort({KEY:1}) 1 为升序排列，而-1是用于降序排列 db.col.createIndex({&quot;title&quot;:1,&quot;description&quot;:-1}) 创建索引 聚合 db.mycol.aggregate([{$group : {_id : &quot;$by_user&quot;, num_tutorial : {$sum : 1}}}])","categories":[{"name":"mongodb","slug":"mongodb","permalink":"http://github/17307/categories/mongodb/"}],"tags":[]},{"title":"ubuntu-ssh","slug":"ubuntu-ssh","date":"2018-06-15T08:47:48.000Z","updated":"2018-06-15T08:51:01.869Z","comments":true,"path":"2018/06/15/ubuntu-ssh/","link":"","permalink":"http://github/17307/2018/06/15/ubuntu-ssh/","excerpt":"关于linux如何配置ssh","text":"关于linux如何配置ssh 关于连接Ubuntu首先需要打开22号端口打开Ubuntu SSH 22端口的方法如下：需要安装OpenSSH server 使用命令安装：sudo apt-get install openssh-server然后重启配置文件:sudo /etc/init.d/ssh restart 配置通过密钥连接ssh 首先在服务器上制作密钥对。首先用密码登录到你打算使用密钥登录的账户，然后执行以下命令：ssh-keygen用户的home目录中生成了一个 .ssh 的隐藏目录，内含两个密钥文件。id_rsa 为私钥，id_rsa.pub 为公钥. 键入以下命令，在服务器上安装公钥： cd .sshcat id_rsa.pub &gt;&gt; authorized_keys 如此便完成了公钥的安装。为了确保连接成功，请保证以下文件权限正确： chmod 600 authorized_keyschmod 700 ~/.ssh –这里路径需要更改 设置 SSH，打开密钥登录功能 编辑 /etc/ssh/sshd_config 文件，进行如下设置：RSAAuthentication yesPubkeyAuthentication yes 另外，请留意 root 用户能否通过 SSH 登录：PermitRootLogin yes 当你完成全部设置，并以密钥方式登录成功后，再禁用密码登录：PasswordAuthentication no 可选 最后，重启 SSH 服务： service sshd restart github 地址 “https://github.com/17307/Learning/blob/master/linux/ssh.md&quot;","categories":[{"name":"linux","slug":"linux","permalink":"http://github/17307/categories/linux/"}],"tags":[]},{"title":"python基础","slug":"python基础","date":"2018-06-09T03:02:34.000Z","updated":"2018-06-09T03:05:50.729Z","comments":true,"path":"2018/06/09/python基础/","link":"","permalink":"http://github/17307/2018/06/09/python基础/","excerpt":"python对象，引用，类","text":"python对象，引用，类 python普通对象python中的变量与对象、可变对象和不可变对象：12a = 3 #创建 int对象 3，创建变量a， 变量a指向对象3 a = \"test\" #创建string对象，变量a指向对象\"test\" 对象：可变对象和不可变对象，不可变对象包括int，float，long，str，tuple等，可变对象包括list，set，dict等。 需要注意的是：这里说的不可变指的是对象值的不可变。 对于不可变类型的对象，如果要更改变量，则会创建一个新值，把变量绑定到新的对象上，而旧值如果没有被引用就等待垃圾回收。 可变类型数据对对象操作的时候，不需要再在其他地方申请内存，只需要在此对象后面连续申请(+/-)即可，也就是它的内存地址会保持不变，但区域会变长或者变短。 浅拷贝和深拷贝 使用copy.copy()，可以进行对象的浅拷贝，它复制了对象，但对于对象中的元素，依然使用原始的引用. 如果需要复制一个容器对象，以及它里面的所有元素（包含元素的子元素），可以使用copy.deepcopy()进行深拷贝 对于非容器类型（如数字、字符串、和其他’原子’类型的对象）没有被拷贝一说 如果元祖变量只包含原子类型对象，则不能深拷贝，看下面的例子 python 类 __init__() 构造函数 __del__() 析构函数 __p 私有属性 __method() 私有方法 方法:__init__ : 构造函数，在生成对象时调用 __del__ : 析构函数，释放对象时使用 __repr__ : 打印，转换 __setitem__ : 按照索引赋值 __getitem__: 按照索引获取值 __len__: 获得长度 __cmp__: 比较运算 __call__: 函数调用 __add__: 加运算 __sub__: 减运算 __mul__: 乘运算 __div__: 除运算 __mod__: 求余运算 __pow__: 乘方 __str__: print()","categories":[{"name":"python","slug":"python","permalink":"http://github/17307/categories/python/"}],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2018-06-07T12:44:54.950Z","updated":"2018-06-06T15:03:02.000Z","comments":true,"path":"2018/06/07/hello-world/","link":"","permalink":"http://github/17307/2018/06/07/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"p","slug":"p","date":"2018-06-07T11:29:14.000Z","updated":"2018-06-07T11:30:16.000Z","comments":true,"path":"2018/06/07/p/","link":"","permalink":"http://github/17307/2018/06/07/p/","excerpt":"","text":"123","categories":[{"name":"python","slug":"python","permalink":"http://github/17307/categories/python/"}],"tags":[]},{"title":"决策树","slug":"决策树","date":"2018-06-06T16:38:16.000Z","updated":"2018-06-07T03:14:26.000Z","comments":true,"path":"2018/06/07/决策树/","link":"","permalink":"http://github/17307/2018/06/07/决策树/","excerpt":"决策树(包括ID3,C4.5)以及sk-learn基础使用","text":"决策树(包括ID3,C4.5)以及sk-learn基础使用 决策树决策树ID3算法的信息论基础 熵度量了事物的不确定性，越不确定的事物，它的熵就越大。具体的，随机变量X的熵的表达式如下： $$info(X)=H(X)=\\sum_{i=1}^{n}{p_i}log_{2}{p_i}$$ 决策树构建 ID3 C4.5 sk-learn来自http://sklearn.apachecn.org/cn/latest/modules/tree.html#tree-multioutput 二分类问题123from sklearn import treefrom sklearn.datasets import load_iris # iris数据import graphviz # 用于导出决策树 12345678910def test1(): X = [[0, 0], [1, 1]] Y = [0, 1] clf = tree.DecisionTreeClassifier() clf = clf.fit(X, Y) # 预测数据值 print(clf.predict([[2., 2.]])) # 预测数据值的概率,与类别一一对应 print(clf.predict_proba([[2., 2.]])) 多分类与展示123456789101112131415161718def test2(): iris = load_iris() clf = tree.DecisionTreeClassifier() clf = clf.fit(iris.data, iris.target) dot_data = tree.export_graphviz(clf, out_file=None) # 数字形式的树 graph = graphviz.Source(dot_data) # 图形化树 graph.render(\"img/iris\") # 生成iris.pdf \"\"\" :func: export_graphviz 出导出还支持各种美化，包括通过他们的类着色节点（或回归值），如果需要，使用显式变量和类名。Jupyter notebook也可以自动找出相同的模块:: dot_data = tree.export_graphviz(clf, out_file=None, # doctest: +SKIP feature_names=iris.feature_names, # doctest: +SKIP class_names=iris.target_names, # doctest: +SKIP filled=True, rounded=True, # doctest: +SKIP special_characters=True) # doctest: +SKIP \"\"\" 回归问题sk-learn 可以用来解决决策树回归算法。决策树通过使用 DecisionTreeRegressor 类也可以用来解决回归问题。 多值输出该模块通过在 DecisionTreeClassifier 和 :class:DecisionTreeRegressor 中实现该策略来支持多输出问题。 使用技巧 对于拥有大量特征的数据决策树会出现过拟合的现象。获得一个合适的样本比例和特征数量十分重要，因为在高维空间中只有少量的样本的树是十分容易过拟合的。 考虑事先进行降维 PCA , ICA ，使树更好地找到具有分辨性的特征。 通过 export 功能可以可视化您的决策树。使用 max_depth=3 作为初始树深度，让决策树知道如何适应数据，然后再增加树的深度。 填充树的样本数量会增加树的每个附加级别。使用 max_depth 来控制输的大小防止过拟合 通过使用 min_samples_split 和 min_samples_leaf 来控制叶节点上的样本数量。当这个值很小时意味着生成的决策树将会过拟合，然而当这个值很大时将会不利于决策树的对样本的学习。所以尝试 min_samples_leaf=5 作为初始值。如果样本的变化量很大，可以使用浮点数作为这两个参数中的百分比。两者之间的主要区别在于 min_samples_leaf 保证叶结点中最少的采样数，而 min_samples_split 可以创建任意小的叶子，尽管在文献中 min_samples_split 更常见 在训练之前平衡您的数据集，以防止决策树偏向于主导类.可以通过从每个类中抽取相等数量的样本来进行类平衡，或者优选地通过将每个类的样本权重 (sample_weight) 的和归一化为相同的值。还要注意的是，基于权重的预修剪标准 (min_weight_fraction_leaf) 对于显性类别的偏倚偏小，而不是不了解样本权重的标准，如 min_samples_leaf 。 如果样本被加权，则使用基于权重的预修剪标准 min_weight_fraction_leaf 来优化树结构将更容易，这确保叶节点包含样本权重的总和的至少一部分。 所有的决策树内部使用 np.float32 数组 ，如果训练数据不是这种格式，将会复制数据集 如果输入的矩阵X为稀疏矩阵，建议您在调用fit之前将矩阵X转换为稀疏的csc_matrix ,在调用predict之前将 csr_matrix 稀疏。当特征在大多数样本中具有零值时，与密集矩阵相比，稀疏矩阵输入的训练时间可以快几个数量级","categories":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://github/17307/categories/Machine-Learning/"}],"tags":[]}]}