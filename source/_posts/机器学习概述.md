---
title: 机器学习概述
date: 2018-09-15 10:16:18
categories: MachineLearning
---


# Numpy基础
## 矩阵以及运算
### 矩阵
首先,我认为,只需要两组数,就可以代表空间.
```python
a = [1, 0]
print(np.shape(a)) # (2,)
a = [[1, 0]] 
print(np.shape(a)) # (1,2)
a = [[1, 0], [0, 1]]
print(np.shape(a)) # (2,2)

"""
而对于有多个矩阵的,类似于数组
"""
a = [[[1, 2], [2, 2]]]
print(np.shape(a)) # (1,2,2)
a = [[[1, 0], [0, 1]], [[2, 1], [3, 2]]]
print(np.shape(a)) # (2,2,2)  ---> 2个2*2的矩阵

c = np.array([[[[5],
                [14]],
               [[14],
                [50]]]])
print(c.shape) # (1, 2, 2, 1)   ----> 1个(2个2*2矩阵)           
print(c.reshape(4)) # [ 5 14 14 50]

```
### 运算
#### np.dot()
矩阵乘法
#### np.outer()
```python
"""
[[1,2],[1,1]] * [[2,3],[1,3]] 
===> 先化成一维矩阵 
[1,2,1,1] * [2,3,1,3]
"""
a = np.array([[1, 2], [1, 1]])
b = np.array([[2, 3], [1, 3]])
np.outer(a, b)
#array([[2, 3, 1, 3],
#       [4, 6, 2, 6],
#       [2, 3, 1, 3],
#       [2, 3, 1, 3]])
```
#### np.multiply()
为对应元素的乘积。

# 数据处理

## 数字特征

### 标准化
```python
from sklearn import preprocessing
import numpy as np
X = np.array([[1., -1., 2.], [2., 0., 0.], [0., 1., -1.]])
X_scaled = preprocessing.scale(X)
print(X_scaled)
```

### 正则化
```python
from sklearn import preprocessing
import numpy as np
X = np.array([[1., -1., 2.], [2., 0., 0.], [0., 1., -1.]])
X_scaled = preprocessing.normalize(X, norm='l2')
print(X_scaled)
```
### 归一化
```python
from sklearn import preprocessing
import numpy as np
X = np.array([[1., -1., 2.], [2., 0., 0.], [0., 1., -1.]])
min_max_scaler = preprocessing.MinMaxScaler()
X_train_minmax = min_max_scaler.fit_transform(X)
print(X_train_minmax)
```

## 文本型特征

[官方文档](http://scikit-learn.org/stable/modules/generated/sklearn.feature_extraction.text.CountVectorizer.html#sklearn.feature_extraction.text.CountVectorizer)  
[中文文档](http://sklearn.apachecn.org/cn/latest/modules/feature_extraction.html)

# 数据读取

可以读取 `csv` 数据

# 效果验证

## 交叉验证

[中文文档](http://sklearn.apachecn.org/cn/latest/modules/cross_validation.html)

